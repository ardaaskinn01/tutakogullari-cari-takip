import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../models/transaction.dart';
import '../../auth/services/supabase_service.dart';

class TransactionRepository {
  final SupabaseClient _supabase;

  TransactionRepository(this._supabase);

  // Add Transaction
  Future<void> addTransaction(Transaction transaction) async {
    final data = transaction.toJson();
    // Remove fields that are autogenerated or looked up
    data.remove('id');
    data.remove('created_by_name'); 
    
    await _supabase.from('transactions').insert(data);
  }

  // Get Transactions with pagination and filtering
  Future<List<Transaction>> getTransactions({
    required String userId,
    required bool isAdmin,
    int? limit,
    int? offset,
    String? typeFilter, // 'income', 'expense', or null
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    dynamic query = _supabase
        .from('transactions')
        .select('*, profiles(email, full_name)');

    // If not admin, only show own transactions
    if (!isAdmin) {
      query = query.eq('created_by', userId);
    }

    // Filter by type
    if (typeFilter != null) {
      query = query.eq('type', typeFilter);
    }

    // Filter by date
    if (startDate != null) {
      query = query.gte('created_at', startDate.toIso8601String());
    }
    if (endDate != null) {
      query = query.lte('created_at', endDate.toIso8601String());
    }

    // Pagination
    if (limit != null && offset != null) {
      query = query.range(offset, offset + limit - 1);
    } else if (limit != null) {
      query = query.limit(limit);
    }

    // Sort
    query = query.order('created_at', ascending: false);

    final List<dynamic> data = await query;

    return data.map((json) {
      return Transaction.fromJson(json as Map<String, dynamic>);
    }).toList();
  }

  // Get Balance (Admin only) - Updated for Payment Methods
  Future<Map<String, double>> getBalance() async {
    final List<dynamic> data = await _supabase
        .from('transactions')
        .select('type, amount, payment_method');

    double totalIncome = 0;
    double totalExpense = 0;
    
    // Payment Method Breakdowns
    double cashIncome = 0;
    double cardIncome = 0;
    double checkIncome = 0;
    
    double cashExpense = 0;
    double cardExpense = 0;
    double checkExpense = 0;

    for (var item in data) {
      final type = item['type'] as String;
      final method = item['payment_method'] as String? ?? 'cash';
      final amount = (item['amount'] as num).toDouble();

      if (type == 'income') {
        totalIncome += amount;
        switch (method) {
          case 'cash': cashIncome += amount; break;
          case 'credit_card': cardIncome += amount; break;
          case 'check_note': checkIncome += amount; break;
        }
      } else if (type == 'expense') {
        totalExpense += amount;
        switch (method) {
          case 'cash': cashExpense += amount; break;
          case 'credit_card': cardExpense += amount; break;
          case 'check_note': checkExpense += amount; break;
        }
      }
    }

    return {
      'total_income': totalIncome,
      'total_expense': totalExpense,
      'net_balance': totalIncome - totalExpense,
      
      'cash_income': cashIncome,
      'card_income': cardIncome,
      'check_income': checkIncome,
      
      'cash_expense': cashExpense,
      'card_expense': cardExpense,
      'check_expense': checkExpense,
    };
  }

  // Update Transaction
  Future<void> updateTransaction(String id, Transaction transaction) async {
    final data = transaction.toJson();
    data.remove('id');
    data.remove('created_at'); 
    data.remove('created_by_name');
    
    // Supabase update checks RLS. If no rows match or policy fails, it returns empty list.
    final List<dynamic> response = await _supabase
        .from('transactions')
        .update(data)
        .eq('id', id)
        .select();

    if (response.isEmpty) {
      throw Exception('Güncelleme gerçekleştirilemedi. Yetki hatası olabilir veya kayıt bulunamadı.');
    }
  }

  // Delete Transaction
  Future<void> deleteTransaction(String id) async {
    final List<dynamic> response = await _supabase
        .from('transactions')
        .delete()
        .eq('id', id)
        .select();

    if (response.isEmpty) {
      throw Exception('Silme gerçekleştirilemedi. Yetki hatası olabilir veya kayıt bulunamadı.');
    }
  }
}

// Repository Provider
final transactionRepositoryProvider = Provider<TransactionRepository>((ref) {
  final supabase = ref.watch(supabaseClientProvider);
  return TransactionRepository(supabase);
});
